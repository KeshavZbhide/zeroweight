/*
* READ THE COMMENTS TO UNDERSTAND HOW BIT COIN WORKS!!!
* Raw Bitcoin Transaction Package.
*/

package main

import "bytes"
import "encoding/hex"
import "github.com/conformal/btcec"
import "fmt"
import "math/big"
import "crypto/sha256"
//import "os"
//import "strconv"
/*
* struct that represents a basics script public key and the amount he/her 
* should recive. 
*/
type txout struct{
    amount uint64;
    script_pub_key []byte;
}

//Temp variables.
var fromAddress string = '1KhefwpMQuMJQnqqTFUn4vSGuVhtm87u2o';
var toAddress string = '1FRBPvxmK6pb58o4rpTD52zB4vWXNvNqLe'
var transferAmount uint64 = 1000000-200000;
var sourceTransaction string = "ecafe20a55a7661a5b8adf6f4adc4911a114437e0bd6f5a3bce47f0e28e3c10d";
var sourceIndex uint32 = 0;
var privateKey []byte = nil;

/*--------------------------------------------Utility Functions-------------------------------------*/

const alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var bigRadix = big.NewInt(58);
var bigZero = big.NewInt(0);

func reverseHexString(s string) string {
    length := len(s);
    result := make([]byte, len(s));
    for i := 0; i < length; i+=2 {
        result[i] = s[length-2-i];
        result[i+1] = s[length-1-i];
    }
    return string(result);
}

func get_uint32_bytes(x uint32) []byte {
    return []byte{
        byte(x),
        byte(x >> 8),
        byte(x >> 16),
        byte(x >> 24),
    };
}

func varint(x uint32) []byte {
    if x < 253 {
        return []byte{byte(x)};
    } else if x < 65535 {
        return []byte{ byte(253), byte(x), byte(x>>8) }
    } else if x < 4294967295 {
        return []byte{ byte(254), byte(x), byte(x>>8), byte(x>>16), byte(x>>24) }
    } else {
        panic("varint for memmory greater than 4GB");
    }
}

/*---------------------------------------------------------------------------------------*/

func make_script_pub_key(pub_key []byte) []byte{
    var script_pub_key bytes.Buffer;
    script_pub_key.Write([]byte{118, 169, 20}); //OP_DUP , OP_HASH160, PUSHDATA 14
    script_pub_key.Write(pub_key); //publickey decoded base58chech encoding
    script_pub_key.Write([]byte{136, 172}); //OP_EQUALVERIFY , OP_CHECKSIG
    return script_pub_key.Bytes();
}

func make_inputs(inputs []*tx_unspent, script_sig []byte) []byte {
    var result bytes.Buffer;
    for i := range inputs {
        txhash,_ := hex.DecodeString(inputs[i].tx_hash);
        result.Write(txhash);
        result.Write(get_uint32_bytes(inputs[i].tx_output_n));
        result.WriteByte(byte(len(script_sig)));
        result.Write(script_sig);
        result.Write(get_uint32_bytes(4294967295));
    }
    return result.Bytes();
}

func make_outputs(outputs []txout) []byte {
    var formated_outputs bytes.Buffer;
    for i := range outputs {
        satoshi := []byte {
            byte( outputs[i].amount ),
            byte( outputs[i].amount >> 8 ),
            byte( outputs[i].amount >> 16 ),
            byte( outputs[i].amount >> 24 ),
            byte( outputs[i].amount >> 32 ),
            byte( outputs[i].amount >> 40 ),
            byte( outputs[i].amount >> 48 ),
            byte( outputs[i].amount >> 56 )}
        script_len := byte(len(outputs[i].script_pub_key));
        formated_outputs.Write(satoshi);
        formated_outputs.WriteByte(script_len);
        formated_outputs.Write(outputs[i].script_pub_key);
    }
    return formated_outputs.Bytes();
}

func make_raw_transaction(inputs []*tx_unspent, script_sig []byte, outputs []txout ) []byte {
    var tx bytes.Buffer;
    formated_outputs := make_outputs(outputs);
    formated_inputs := make_inputs(inputs, script_sig);
    tx.Write([]byte{1, 0, 0, 0}); //4 byte version
    tx.WriteByte(byte(len(inputs)));//Number of Inputs
    tx.Write(formated_inputs);
    tx.WriteByte(byte(len(outputs))); //
    tx.Write(formated_outputs);
    tx.Write([]byte{0, 0, 0, 0});
    return tx.Bytes();
}

func Tx(private_k string, to_public_k string, amount uint64) []byte {

    inputs := make([]*tx_unspent, 1);
    inputs[0] = new(tx_unspent);
    inputs[0].tx_hash = reverseHexString(sourceTransaction);
    inputs[0].tx_output_n = sourceIndex;

    private_key, temp_pub_key := btcec.PrivKeyFromBytes(btcec.S256(), base58CheckDecodeKey(privateKey));
    //public_key := append(append([]byte{4}, temp_pub_key.X.Bytes()...), temp_pub_key.Y.Bytes()...);

    script_pub_key := make_script_pub_key(public_key);
    outputs := make([]txout, 1);
    outputs[0] = txout{transferAmount, make_script_pub_key(base58CheckDecodeKey(""))};

    raw_tx := append(
        make_raw_transaction(inputs, script_pub_key, outputs),
        get_uint32_bytes(16777216)...); //hash_code

    s256_0 := sha256.Sum256(raw_tx);
    s256 := sha256.Sum256(s256_0[:]);
    fmt.Println("Hash of rawTX --->\n", hex.EncodeToString(s256[:]), "\n");

    temp_sig,_ := private_key.Sign(s256[:]);
    signature := temp_sig.Serialize();
    //After appending the sighash all bytes, we get the final signature.
    signature = append(signature, byte(1));
    //Now Build script sig bytes.
    var script_sig bytes.Buffer;
    script_sig.Write(varint(uint32(len(signature))));
    script_sig.Write(signature);
    script_sig.Write(varint(uint32(len(public_key))));
    script_sig.Write(public_key);
    signed_tx := make_raw_transaction(inputs, script_sig.Bytes(), outputs);
    return signed_tx;
}

func main_hold() {
    tx := Tx("5KGXHdT9RFweNrwLNcxSdniCzT82scnGAnoXQVwFGwiWELj4FGn",
            "1FRBPvxmK6pb58o4rpTD52zB4vWXNvNqLe", uint64(1000000));

    /*printwithspace := func (s string) {
        len_s := len(s);
        for i := 0; i < len_s; i+=2 {
            fmt.Printf("%c%c ",s[i], s[i+1]);
        }
        fmt.Println();
    }*/
    //printwithspace(hex.EncodeToString(tx));
    //fmt.Println("HEX<->PASTE");
    fmt.Println(hex.EncodeToString(tx));
    /*satoshi,_ := strconv.ParseUint(os.Args[2], 10, 64);
    use, change, err := get_unspent(os.Args[1], satoshi)
    if err != nil {
        fmt.Println(err);
    }
    if (use == nil)  || (len(use) == 0) {
        if use == nil {
            fmt.Println("got nil");
        }
        fmt.Println("insufficient funds");
    }
    for i := range use {
        fmt.Println(use[i].tx_hash, " tx_output_n:", use[i].tx_output_n);
    }
    fmt.Println("change to return --> ", change);*/
}

