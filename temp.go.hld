package main

import "fmt"
import "github.com/conformal/btcec"
import "crypto/ecdsa"
import "crypto/rand"
import "crypto/sha256"
import "crypto/aes"
import "code.google.com/p/go.crypto/ripemd160"
import "encoding/hex"
import "bytes"

func publicKeyStructToPublicKeyBytes(key *ecdsa.PublicKey) []byte {
    xylen := len(key.X.Bytes());
    keyBytes := make([]byte, 1+(2*xylen));
    keyBytes[0] = byte(4);
    copied := copy(keyBytes[1:], key.X.Bytes());
    copy(keyBytes[(1+copied):], key.Y.Bytes());
    return keyBytes;
}

func publicKeyHash(key []byte) []byte {
    s256 := sha256.Sum256(key);
    ripemd160Hash := ripemd160.New();
    ripemd160Hash.Write(s256[:]);
    return ripemd160Hash.Sum(nil);
}


func GenKeys() (string, string) {
    privateKeyStrut, err := ecdsa.GenerateKey(btcec.S256(), rand.Reader);
    if err != nil {
        fmt.Println(err);
        return "", "";
    }
    privateKeyWif := base58CheckEncodeKey(0x80, privateKeyStrut.D.Bytes());
    publicKeyBytes := publicKeyStructToPublicKeyBytes(&(privateKeyStrut.PublicKey));
    hash0 := sha256.Sum256(publicKeyBytes);
    ripemd160 := ripemd160.New();
    ripemd160.Write(hash0[:]);
    keyHash := ripemd160.Sum(nil);
    publicKeyWif := base58CheckEncodeKey(0,keyHash);
    return privateKeyWif, publicKeyWif;
}

func main() {
    privateKey, publicKey := GenKeys();
    content := "{"+privateKey+"::"+publicKey+"}";
    fmt.Println("encrypting =>", content);
    encryptionKey := make([]byte, 16);
    copy(encryptionKey, []byte("HelloWorld!"));
    aesCipher, err := aes.NewCipher(encryptionKey);
    cBlockLen := aesCipher.BlockSize();
    if err != nil {
        fmt.Println("error =>", err.Error());
        return;
    }
    toEncLen := len(content) + (cBlockLen - (len(content) % cBlockLen));
    toEncrypt := make([]byte, toEncLen);
    copy(toEncrypt, []byte(content));
    for i := 0; i < toEncLen; i += 16 {
        slice := toEncrypt[i:(i+cBlockLen)];
        aesCipher.Encrypt(slice, slice);
    }
    wallet := hex.EncodeToString(toEncrypt);
    fmt.Println("result =>\n",wallet);
    WalletDecrypter(wallet, "HelloWorld!");
}

func WalletDecrypter(content string, pass string) {
    //temp,_ := hex.DecodeString(content);
    contentBytes,_ := hex.DecodeString(content);
    contentBytesLen := len(contentBytes);
    encryptionKey := make([]byte, 16);
    copy(encryptionKey, []byte(pass));
    aesCipher,err := aes.NewCipher(encryptionKey);
    if err != nil {
        fmt.Println("error =>", err.Error());
    }
    cBlockLen := aesCipher.BlockSize();
    for i := 0; i < contentBytesLen; i += cBlockLen {
        slice := contentBytes[i:(i+cBlockLen)];
        aesCipher.Decrypt(slice, slice);
    }
    result := string(contentBytes);
    fmt.Println("Decrypt =>",result);
    fmt.Println("Decrypt String len =>", len(result));
    limit := bytes.IndexByte(contentBytes, 0);
    var result2 string;
    if limit != -1 {
        result2 = string(contentBytes[0:limit])
    } else {
        result2 = string(contentBytes);
    }
    fmt.Println("Decrypt String2 =>", result2);
    fmt.Println("Decrypt String2 len => ", len(result2));
}
